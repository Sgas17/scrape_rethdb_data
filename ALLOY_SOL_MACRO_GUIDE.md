# Alloy sol! Macro Guide - Decoding Contract Calls

## What We Just Built

We successfully tested Alloy v1.0's `sol!` macro to decode Uniswap V2 `getReserves()` calls. This is **the modern, type-safe way** to interact with Ethereum contracts in Rust.

## Working Example

See: [`examples/test_uniswap_v2_reserves.rs`](examples/test_uniswap_v2_reserves.rs)

```bash
cargo run --example test_uniswap_v2_reserves
```

**Output:**
```
✅ Successfully decoded reserves using Alloy sol! macro:
  Reserve0 (USDC): 25022268357058
  Reserve1 (WETH): 6323133955233645484172
  Block Timestamp: 1761304295
```

## How It Works

### Step 1: Define Contract Interface with `sol!` Macro

```rust
use alloy::sol;

sol! {
    #[sol(rpc)]  // CRITICAL: This generates .call() methods
    contract IUniswapV2Pair {
        function getReserves() external view returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        );
    }
}
```

**Key Points:**
- Use `#[sol(rpc)]` attribute to auto-generate RPC bindings
- Use `contract` keyword (not `interface`)
- Copy the function signature directly from Solidity

### Step 2: Create Provider & Contract Instance

```rust
use alloy::primitives::Address;
use alloy::providers::ProviderBuilder;

let rpc_url = "http://100.104.193.35:8545";
let pool_address = Address::from_str("0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc")?;

// Create provider
let provider = ProviderBuilder::new().connect_http(rpc_url.parse()?);

// Create contract instance - auto-generated by sol! macro
let pool = IUniswapV2Pair::new(pool_address, provider);
```

### Step 3: Call Function & Decode Result

```rust
// Call the function - Alloy handles ALL encoding/decoding!
let result = pool.getReserves().call().await?;

// Access fields from auto-generated struct
let reserve0 = result.reserve0.to::<u128>();  // Convert Uint<112> to u128
let reserve1 = result.reserve1.to::<u128>();
let timestamp = result.blockTimestampLast;    // u32 works directly

println!("Reserve0: {}", reserve0);
println!("Reserve1: {}", reserve1);
```

## Type Conversions

Alloy uses strongly-typed `Uint<N, L>` for Solidity integers:

```rust
// Solidity → Rust Type Mapping
uint112 → Uint<112, 2>  // Need .to::<u128>()
uint32  → u32            // Works directly
uint256 → Uint<256, 4>   // Need .to::<U256>() or other conversion
address → Address        // Works directly
```

**Convert Alloy types:**
```rust
let value: u128 = uint112_value.to::<u128>();
let value: u64 = uint64_value.to::<u64>();
let value: U256 = uint256_value.to::<U256>();
```

## Why This Is Better Than Manual Decoding

### ❌ Old Way (Manual ABI Decoding)
```rust
// Have to manually construct function selector
let selector = keccak256("getReserves()")[0..4];

// Manual eth.call
let result = provider.call(...)

// Manual ABI decoding
let decoded = decode(["uint112", "uint112", "uint32"], result)?;
let reserve0 = decoded[0].as_uint().unwrap().to::<u128>();
// Error-prone, verbose, no type safety!
```

### ✅ New Way (Alloy sol! macro)
```rust
let result = pool.getReserves().call().await?;
let reserve0 = result.reserve0.to::<u128>();
// Type-safe, auto-complete, compile-time checks!
```

## Expanding to Other Contracts

### Example: Uniswap V3 Pool

```rust
sol! {
    #[sol(rpc)]
    contract IUniswapV3Pool {
        function slot0() external view returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        );

        function liquidity() external view returns (uint128);

        function ticks(int24 tick) external view returns (
            uint128 liquidityGross,
            int128 liquidityNet,
            uint256 feeGrowthOutside0X128,
            uint256 feeGrowthOutside1X128,
            int56 tickCumulativeOutside,
            uint160 secondsPerLiquidityOutsideX128,
            uint32 secondsOutside,
            bool initialized
        );
    }
}

// Usage
let pool = IUniswapV3Pool::new(pool_address, provider);
let slot0 = pool.slot0().call().await?;
let liquidity = pool.liquidity().call().await?;
let tick_data = pool.ticks(tick_index).call().await?;
```

### Example: ERC20 Token

```rust
sol! {
    #[sol(rpc)]
    contract IERC20 {
        function balanceOf(address account) external view returns (uint256);
        function totalSupply() external view returns (uint256);
        function decimals() external view returns (uint8);
        function symbol() external view returns (string);
    }
}

let token = IERC20::new(token_address, provider);
let balance = token.balanceOf(user_address).call().await?;
let supply = token.totalSupply().call().await?;
```

## Common Patterns for Our Use Cases

### Pattern 1: Batch Multicall (Get Multiple Ticks)

```rust
sol! {
    #[sol(rpc)]
    contract IUniswapV3Pool {
        function ticks(int24 tick) external view returns (
            uint128 liquidityGross,
            int128 liquidityNet,
            uint256 feeGrowthOutside0X128,
            uint256 feeGrowthOutside1X128,
            int56 tickCumulativeOutside,
            uint160 secondsPerLiquidityOutsideX128,
            uint32 secondsOutside,
            bool initialized
        );
    }
}

// Batch fetch multiple ticks
let pool = IUniswapV3Pool::new(pool_address, provider);
let mut tick_data = Vec::new();

for tick in tick_list {
    let data = pool.ticks(tick).call().await?;
    tick_data.push((
        tick,
        data.liquidityGross.to::<u128>(),
        data.liquidityNet.to::<i128>(),
    ));
}
```

### Pattern 2: Historical Block Data

```rust
use alloy::rpc::types::BlockId;

// Call at specific block
let result = pool
    .getReserves()
    .block(BlockId::Number(block_number.into()))
    .call()
    .await?;
```

### Pattern 3: Multiple Pools in Parallel

```rust
use futures::future::join_all;

let pools = vec![pool1_addr, pool2_addr, pool3_addr];

let futures: Vec<_> = pools.iter().map(|addr| {
    let pool = IUniswapV2Pair::new(*addr, provider.clone());
    async move {
        pool.getReserves().call().await
    }
}).collect();

let results = join_all(futures).await;
```

## Key Dependencies in Cargo.toml

```toml
[dependencies]
alloy = { version = "1.0", features = ["full"] }
tokio = { version = "1", features = ["full"] }
```

## Common Gotchas

1. **Missing `#[sol(rpc)]` attribute** → No `.call()` method generated
2. **Using `interface` instead of `contract`** → Different code generation
3. **Forgetting `.to::<T>()` conversion** → Type errors with Uint types
4. **Wrong Solidity types** → Silent bugs! Copy signatures exactly from verified contracts

## Performance Notes

- **sol! macro**: Zero-cost abstraction, compiles to optimized code
- **Type safety**: Catches errors at compile time, not runtime
- **Auto-complete**: Your IDE knows all function signatures and return types

## Next Steps for Our Project

We can now use this pattern to:

1. **Fetch V3 tick data** from Uniswap V3 pools efficiently
2. **Decode V2 reserves** for all pairs in parallel
3. **Get pool metadata** (token0, token1, fee, etc.)
4. **Query historical states** at specific blocks
5. **Build type-safe batch fetchers** for liquidity snapshots

All with **compile-time type checking** and **zero manual ABI decoding**!

## Testing Your Own Contracts

1. Get the contract ABI/interface from Etherscan
2. Copy the function signatures into `sol!` macro
3. Add `#[sol(rpc)]` attribute
4. Call `.new(address, provider)` and start using!

---

**Example created**: [`examples/test_uniswap_v2_reserves.rs`](examples/test_uniswap_v2_reserves.rs)
**Run**: `cargo run --example test_uniswap_v2_reserves`
